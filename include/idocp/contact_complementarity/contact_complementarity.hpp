#ifndef IDOCP_CONTACT_COMPLEMENTARITY_HPP_
#define IDOCP_CONTACT_COMPLEMENTARITY_HPP_

#include <vector>

#include "Eigen/Core"

#include "idocp/robot/robot.hpp"
#include "idocp/ocp/split_solution.hpp"
#include "idocp/ocp/split_direction.hpp"
#include "idocp/ocp/kkt_residual.hpp"
#include "idocp/ocp/kkt_matrix.hpp"
#include "idocp/contact_complementarity/distance_to_contact_surface.hpp"
#include "idocp/contact_complementarity/contact_normal_force.hpp"
#include "idocp/contact_complementarity/friction_cone.hpp"
#include "idocp/constraints/constraint_component_data.hpp"


namespace idocp {

///
/// @typedef ContactComplementarity
/// @brief Base class for constraint components. 
///
class ContactComplementarity {
public:
  ///
  /// @brief Constructor. 
  /// @param[in] barrier Barrier parameter. Must be positive. Should be small.
  /// @param[in] fraction_to_boundary_rate Must be larger than 0 and smaller 
  /// than 1. Should be between 0.9 and 0.995.
  ///
  ContactComplementarity(const Robot& robot);

  ///
  /// @brief Default constructor. 
  ///
  ContactComplementarity();

  ///
  /// @brief Destructor. 
  ///
  ~ContactComplementarity();

  ///
  /// @brief Default copy constructor. 
  ///
  ContactComplementarity(const ContactComplementarity&) = default;

  ///
  /// @brief Default copy operator. 
  ///
  ContactComplementarity& operator=(const ContactComplementarity&) = default;

  ///
  /// @brief Default move constructor. 
  ///
  ContactComplementarity(ContactComplementarity&&) noexcept = default;

  ///
  /// @brief Default move assign operator. 
  ///
  ContactComplementarity& operator=(ContactComplementarity&&) noexcept = default;

  ///
  /// @brief Check whether the current solution s is feasible or not. 
  /// @param[in] robot Robot model.
  /// @param[in] s Split solution.
  /// @return true if s is feasible. false if not.
  ///
  bool isFeasible(Robot& robot, const SplitSolution& s);

  void setContactStatus(const Robot& robot);

  ///
  /// @brief Set the slack and dual variables of each constraint components. 
  /// @param[in] robot Robot model.
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  ///
  void setSlackAndDual(Robot& robot, const double dtau, 
                       const SplitSolution& s);

  ///
  /// @brief Augment the dual residual of the constraints to the KKT residual 
  /// with respect to the configuration, velocity, acceleration, and contact 
  /// forces.
  /// @param[in] robot Robot model.
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[out] kkt_residual KKT residual.
  ///
  void augmentDualResidual(Robot& robot, const double dtau, 
                           const SplitSolution& s, KKTResidual& kkt_residual);

  ///
  /// @brief Consense slack and dual of the constraints and factorize condensed
  /// KKT Hessian and residual with respect to the configuration, velocity, 
  /// acceleration, and contact forces. 
  /// @param[in] robot Robot model.
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[out] kkt_matrix The KKT matrix. The condensed Hessians are added  
  /// to this data.
  /// @param[out] kkt_residual KKT residual. The condensed residual are added 
  /// to this data.
  ///
  void condenseSlackAndDual(Robot& robot, const double dtau, 
                            const SplitSolution& s, KKTMatrix& kkt_matrix, 
                            KKTResidual& kkt_residual);

  ///
  /// @brief Compute directions of slack and dual.
  /// @param[in] robot Robot model.
  /// @param[in, out] data Constraints data generated by 
  /// Constraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @param[in] d Split direction.
  ///
  void computeSlackAndDualDirection(Robot& robot, const double dtau, 
                                    const SplitSolution& s, 
                                    const SplitDirection& d);

  ///
  /// @brief Computes and return the L1-norm of the primal residual and duality
  /// of the constraints. 
  /// @param[in] robot Robot model.
  /// @param[in] data Constraints data generated by 
  /// Constraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @return L1 norm of the primal residual and duality of the constraints. 
  ///
  double residualL1Nrom(Robot& robot, const double dtau, 
                        const SplitSolution& s);

  ///
  /// @brief Computes and return the squared norm of the primal residual and 
  /// duality of the constraints. 
  /// @param[in] robot Robot model.
  /// @param[in] data Constraints data generated by 
  /// Constraints::createConstraintsData().
  /// @param[in] dtau Time step.
  /// @param[in] s Split solution.
  /// @return Squared norm of the primal residual and duality of the constraints. 
  ///
  double squaredKKTErrorNorm(Robot& robot, const double dtau, 
                             const SplitSolution& s);

  ///
  /// @brief Compute and returns the maximum step size by applying 
  /// fraction-to-boundary-rule to the direction of slack.
  /// @return Maximum step size of the slack.
  ///
  double maxSlackStepSize() const;

  ///
  /// @brief Compute and returns the maximum step size by applying 
  /// fraction-to-boundary-rule to the direction of dual.
  /// @return Maximum step size of the dual.
  ///
  double maxDualStepSize() const;

  ///
  /// @brief Updates the slack with step_size.
  /// @param[in] step_size Step size. 
  ///
  void updateSlack(const double step_size);

  ///
  /// @brief Updates the dual with step_size.
  /// @param[in] step_size Step size. 
  ///
  void updateDual(const double step_size);

  ///
  /// @brief Computes and returns the value of the barrier function for slack 
  /// variables.
  /// @return Value of the barrier function. 
  ///
  double costSlackBarrier() const;

  ///
  /// @brief Computes and returns the value of the barrier function for slack 
  /// variables with the step_size.
  /// @param[in] step_size Step size. 
  /// @return Value of the barrier function. 
  ///
  double costSlackBarrier(const double step_size) const;

  ///
  /// @brief Set the barrier parameter.
  /// @param[in] barrier Barrier parameter. Must be positive. Should be small.
  ///
  void setBarrier(const double barrier);

  ///
  /// @brief Set the fraction to boundary rate.
  /// @param[in] fraction_to_boundary_rate Must be larger than 0 and smaller 
  /// than 1. Should be between 0.9 and 0.995.
  ///
  void setFractionToBoundaryRate(const double fraction_to_boundary_rate);

private:
  DistanceToContactSurface distance_to_contact_surface_constraint_;
  ContactNormalForce contact_normal_force_constraint_;
  FrictionCone friction_cone_constraint_;
  ConstraintComponentData distance_to_contact_surface_constraint_data_, 
                          contact_normal_force_constraint_data_, 
                          friction_cone_constraint_data_;
  std::vector<bool> is_each_contact_active_;
};

} // namespace idocp

#include "idocp/contact_complementarity/contact_complementarity.hxx"

#endif // IDOCP_CONTACT_COMPLEMENTARITY_HPP_ 